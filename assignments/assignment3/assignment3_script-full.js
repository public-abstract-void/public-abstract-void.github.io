class Renderer
{constructor(canvas)
{this._canvas=canvas;this._objects=[];this._clearColor={r:0,g:56/255,b:101/255,a:1}}
async init()
{if(!navigator.gpu){throw Error("WebGPU is not supported in this browser.");}
const adapter=await navigator.gpu.requestAdapter();if(!adapter){throw Error("Couldn't request WebGPU adapter.");}
this._device=await adapter.requestDevice();this._context=this._canvas.getContext("webgpu");this._canvasFormat=navigator.gpu.getPreferredCanvasFormat();this._context.configure({device:this._device,format:this._canvasFormat,});this.resizeCanvas();window.addEventListener('resize',this.resizeCanvas.bind(this));}
resizeCanvas()
{const devicePixelRatio=window.devicePixelRatio||1;const width=window.innerWidth*devicePixelRatio;const height=window.innerHeight*devicePixelRatio;this._canvas.width=width;this._canvas.height=height;this._canvas.style.width=`${window.innerWidth}px`;this._canvas.style.height=`${window.innerHeight}px`;this.render();}
async appendSceneObject(obj){await obj.init();this._objects.push(obj);}
renderToSelectedView(outputView){for(const obj of this._objects){obj?.updateGeometry();}
let encoder=this._device.createCommandEncoder();const pass=encoder.beginRenderPass({colorAttachments:[{view:outputView,clearValue:this._clearColor,loadOp:"clear",storeOp:"store",}]});for(const obj of this._objects){obj?.render(pass);}
pass.end();const computePass=encoder.beginComputePass();for(const obj of this._objects){obj?.compute(computePass);}
computePass.end();const commandBuffer=encoder.finish();this._device.queue.submit([commandBuffer]);}
render(){this.renderToSelectedView(this._context.getCurrentTexture().createView());}}
class PGA2D{static geometricProduct(a,b){return[a[0]*b[0]-a[1]*b[1],a[0]*b[1]+a[1]*b[0],a[0]*b[2]+a[1]*b[3]+a[2]*b[0]-a[3]*b[1],a[0]*b[3]-a[1]*b[2]+a[2]*b[1]+a[3]*b[0]];}
static reverse(a){return[a[0],-a[1],-a[2],-a[3]];}
static applyMotor(p,m){return PGA2D.geometricProduct(m,PGA2D.geometricProduct(p,PGA2D.reverse(m)));}
static motorNorm(m){return Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]+m[3]*m[3]);}
static createTranslator(dx,dy){return[1,0,-dx/2,-dy/2]}
static createRotor(angle,cx=0,cy=0){let p=PGA2D.createPoint(cx,cy);return[Math.cos(angle/2),Math.sin(angle/2)*p[1],Math.sin(angle/2)*p[2],Math.sin(angle/2)*p[3]];}
static createPoint(x,y){return[0,1,y,-x];}
static extractPoint(p){return[-p[3]/p[1],p[2]/p[1]];}
static normalizeMotor(m){let mnorm=PGA2D.motorNorm(m);if(mnorm==0.0){return[1,0,0,0];}
return[m[0]/mnorm,m[1]/mnorm,m[2]/mnorm,m[3]/mnorm];}
static applyMotorToPoint(p,m){let new_p=PGA2D.applyMotor(PGA2D.createPoint(p[0],p[1]),m);return PGA2D.extractPoint(new_p);};static isInside(v0,v1,p){const edge=PGA2D.createPoint(v1[0]-v0[0],v1[1]-v0[1]);const point=PGA2D.createPoint(p[0]-v0[0],p[1]-v0[1]);return(v1[0]-v0[0])*(p[1]-v0[1])-(v1[1]-v0[1])*(p[0]-v0[0])>0;}}
class Camera
{constructor()
{this._pose=new Float32Array([1,0,0,0,1,1]);}
updatePose(pose)
{for(let i=0;i<this._pose.length-2;++i){this._pose[i]=pose[i];}}
moveLeft(d){let dt=PGA2D.createTranslator(-d,0);let newpose=PGA2D.normalizeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
moveRight(d){let dt=PGA2D.createTranslator(d,0);let newpose=PGA2D.normalizeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
moveUp(d){let dt=PGA2D.createTranslator(0,d);let newpose=PGA2D.normalizeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
moveDown(d){let dt=PGA2D.createTranslator(0,-d);let newpose=PGA2D.normalizeMotor(PGA2D.geometricProduct(dt,[this._pose[0],this._pose[1],this._pose[2],this._pose[3]]));this.updatePose(newpose);}
zoomIn(){this._pose[4]*=1.1;this._pose[5]*=1.1;}
zoomOut(){this._pose[4]/=1.1;this._pose[5]/=1.1;}}
class SceneObject{static _objectCnt=0;constructor(device,canvasFormat,shaderFile){if(this.constructor==SceneObject){throw new Error("Abstract classes can't be instantiated.");}
this._device=device;this._canvasFormat=canvasFormat;this._shaderFile=shaderFile;SceneObject._objectCnt+=1;}
getName(){return this.constructor.name+" "+SceneObject._objectCnt.toString();}
async init(){await this.createGeometry();await this.createShaders();await this.createRenderPipeline();await this.createComputePipeline();}
async createGeometry(){throw new Error("Method 'createGeometry()' must be implemented.");}
updateGeometry(){}
loadShader(filename){return new Promise((resolve,reject)=>{const xhttp=new XMLHttpRequest();xhttp.open("GET",filename);xhttp.setRequestHeader("Cache-Control","no-cache, no-store, max-age=0");xhttp.onload=function(){if(xhttp.readyState===XMLHttpRequest.DONE&&xhttp.status===200){resolve(xhttp.responseText);}
else{reject({status:xhttp.status,statusText:xhttp.statusText});}};xhttp.onerror=function(){reject({status:xhttp.status,statusText:xhttp.statusText});};xhttp.send();});}
async createShaders(){let shaderCode=await this.loadShader(this._shaderFile);this._shaderModule=this._device.createShaderModule({label:" Shader "+this.getName(),code:shaderCode,});}
async createRenderPipeline(){throw new Error("Method 'createRenderPipeline()' must be implemented.");}
render(pass){throw new Error("Method 'render(pass)' must be implemented.");}
async createComputePipeline(){throw new Error("Method 'createComputePipeline()' must be implemented.");}
compute(pass){throw new Error("Method 'compute(pass)' must be implemented.");}};class Camera2DVertexObject extends SceneObject{constructor(device,canvasFormat,cameraPose,vertices,shaderFile,topology,numInstances){super(device,canvasFormat,shaderFile);this._cameraPose=cameraPose;this._vertices=vertices;this._topology=topology;this._numInstances=numInstances;}
async createGeometry(){this._vertexBuffer=this._device.createBuffer({label:"Vertices "+this.getName(),size:this._vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._vertexBuffer,0,this._vertices);this._vertexBufferLayout={arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0,}],};this._cameraPoseBuffer=this._device.createBuffer({label:"Camera Pose "+this.getName(),size:this._cameraPose.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,});this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);}
updateCameraPose(){this._device.queue.writeBuffer(this._cameraPoseBuffer,0,this._cameraPose);}
async createRenderPipeline(){this._renderPipeline=this._device.createRenderPipeline({label:"Render Pipeline "+this.getName(),layout:"auto",vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]},primitive:{topology:this._topology}});this._bindGroup=this._device.createBindGroup({label:"Renderer Bind Group "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}}],});}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroup);pass.draw(this._vertices.length/2,this._numInstances);}
async createComputePipeline(){}
compute(pass){}};const GRID_DIMENSIONX=2048;const GRID_DIMENSIONY=GRID_DIMENSIONX;const GRID=4;class Grid extends Camera2DVertexObject
{async createGeometry(){super.createGeometry();this._cellStatus=new Uint32Array(GRID_DIMENSIONX*GRID_DIMENSIONY);this._cellStateBuffers=[this._device.createBuffer({label:"Grid status Buffer 1 "+this.getName(),size:this._cellStatus.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,}),this._device.createBuffer({label:"Grid status Buffer 2 "+this.getName(),size:this._cellStatus.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,})];this.reset();this._step=0;}
reset()
{for(let i=0;i<this._cellStatus.length;i++)
{this._cellStatus[i]=Math.round(Math.random());}
this._device.queue.writeBuffer(this._cellStateBuffers[0],0,this._cellStatus);}
async createRenderPipeline(){super.createRenderPipeline();this._bindGroups=[this._device.createBindGroup({label:"Grid Bind Group 1 "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}},{binding:1,resource:{buffer:this._cellStateBuffers[0]}},{binding:2,resource:{buffer:this._cellStateBuffers[1]}}],}),this._device.createBindGroup({label:"Grid Bind Group 2 "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}},{binding:1,resource:{buffer:this._cellStateBuffers[1]}},{binding:2,resource:{buffer:this._cellStateBuffers[0]}}],})];}
render(pass){pass.setPipeline(this._renderPipeline);pass.setVertexBuffer(0,this._vertexBuffer);pass.setBindGroup(0,this._bindGroups[this._step%2]);pass.draw(this._vertices.length/2,this._numInstances);}
async createRenderPipeline(){this._bindGroupLayout=this._device.createBindGroupLayout({label:"Grid Bind Group Layout "+this.getName(),entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]});this._pipelineLayout=this._device.createPipelineLayout({label:"Grid Pipeline Layout",bindGroupLayouts:[this._bindGroupLayout],});this._renderPipeline=this._device.createRenderPipeline({label:"Grid Render Pipeline "+this.getName(),layout:this._pipelineLayout,vertex:{module:this._shaderModule,entryPoint:"vertexMain",buffers:[this._vertexBufferLayout]},fragment:{module:this._shaderModule,entryPoint:"fragmentMain",targets:[{format:this._canvasFormat}]},primitive:{topology:this._topology}});this._bindGroups=[this._device.createBindGroup({label:"Grid Bind Group 1 "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}},{binding:1,resource:{buffer:this._cellStateBuffers[0]}},{binding:2,resource:{buffer:this._cellStateBuffers[1]}}],}),this._device.createBindGroup({label:"Grid Bind Group 2 "+this.getName(),layout:this._renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this._cameraPoseBuffer}},{binding:1,resource:{buffer:this._cellStateBuffers[1]}},{binding:2,resource:{buffer:this._cellStateBuffers[0]}}],})];}
async createComputePipeline(){this._computePipeline=this._device.createComputePipeline({label:"Grid update pipeline "+this.getName(),layout:this._pipelineLayout,compute:{module:this._shaderModule,entryPoint:"computeMain",}});}
compute(pass){pass.setPipeline(this._computePipeline);pass.setBindGroup(0,this._bindGroups[this._step%2]);pass.dispatchWorkgroups(Math.ceil(GRID_DIMENSIONX/GRID),Math.ceil(GRID_DIMENSIONY/GRID));++this._step;}};class StandardTextObject{constructor(inputText,posy=10,spacing=5,textFont='18px Arial'){this._textFont=textFont;this._lineSpacing=spacing;this._textCanvas=document.createElement('canvas');this._textContext=this._textCanvas.getContext('2d');this.updateTextRegion(inputText);this.updateText(inputText);this._textCanvas.style.position='absolute';this._textCanvas.style.top=posy+'px';this._textCanvas.style.left='10px';this._textCanvas.style.border='1px solid red';document.body.appendChild(this._textCanvas);}
updateTextRegion(newText){this._textContext.font=this._textFont;this._lines=newText.split('\n');this._width=Math.max(...this._lines.map(line=>this._textContext.measureText(line).width));const match=this._textFont.match(/(\d+)px/);if(match){this._fontSize=parseInt(match[1],10);}
else{this._fontSize=18;this._textFont="18px Arial";}
this._height=this._lines.length*(this._fontSize+this._lineSpacing);this._paddingx=5;this._paddingtop=3;this._canvasWidth=Math.ceil(this._width+this._paddingx*2);this._canvasHeight=Math.ceil(this._height+this._paddingtop);this._textCanvas.width=this._canvasWidth;this._textCanvas.height=this._canvasHeight;this._textContext.font=this._textFont;this._textContext.textBaseline='top';}
updateText(newText){this._lines=newText.split('\n');this._textContext.fillStyle='rgba(1, 1, 1, 0.5)';this._textContext.clearRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillRect(0,0,this._canvasWidth,this._canvasHeight);this._textContext.fillStyle='white';this._lines.forEach((line,idx)=>{const x=this._paddingx;const y=this._paddingtop+idx*(this._fontSize+this._lineSpacing);this._textContext.fillText(line,x,y);});}
toggleVisibility(){this._textCanvas.hidden=!this._textCanvas.hidden;}};;var vertices=new Float32Array([-.7,-.7,.7,-.7,.7,.7,-.7,.7,-.7,-.7]);const DIMENSION=2048;const FPS=20;var tgtFPS=FPS;var frameCnt=0;var secPerFrame;var frameInterval;var lastCalled;function do_fps_stuff(input)
{tgtFPS=input;secPerFrame=1./tgtFPS;frameInterval=secPerFrame*1000;}
function mouseToNDC(e){const x=(e.clientX/window.innerWidth)*2-1;const y=(-e.clientY/window.innerHeight)*2+1;return[x,y];}
async function init(){const canvasTag=document.createElement('canvas');canvasTag.id="renderCanvas";document.body.appendChild(canvasTag);const renderer=new Renderer(canvasTag);await renderer.init();let camera=new Camera();var triangle=new Grid(renderer._device,renderer._canvasFormat,camera._pose,vertices,"./optimized_grid.wgsl","triangle-strip",DIMENSION*DIMENSION);await renderer.appendSceneObject(triangle);new StandardTextObject("WELCOME TO GAME OF LIFE!!!!");new StandardTextObject("q/e to zoom camera in/out",40);new StandardTextObject("wasd to move camera up/left/right/down",70);new StandardTextObject("(mouse can also be used to move up/left/right/down)",100);new StandardTextObject("p to pause/unpause",130);new StandardTextObject("r to reset",160);let fps='??';var fpsText=new StandardTextObject('fps: '+fps,190);var movespeed=0.05;window.addEventListener("keydown",(e)=>{switch(e.key){case'f':case'F':fpsText.toggleVisibility();break;case'ArrowUp':case'w':case'W':camera.moveUp(movespeed);triangle.updateCameraPose();break;case'ArrowDown':case's':case'S':camera.moveDown(movespeed);triangle.updateCameraPose();break;case'ArrowLeft':case'a':case'A':camera.moveLeft(movespeed);triangle.updateCameraPose();break;case'ArrowRight':case'd':case'D':camera.moveRight(movespeed);triangle.updateCameraPose();break;case'q':case'Q':camera.zoomIn();triangle.updateCameraPose();break;case'e':case'E':camera.zoomOut();triangle.updateCameraPose();break;case'p':case'P':do_fps_stuff(tgtFPS>0?0:FPS);break;case'r':case'R':frameCnt=0;triangle.reset();break;}});let prevP={x:0,y:0};let dragging=false;canvasTag.addEventListener('mousemove',(e)=>{const mouseX=e.clientX;const mouseY=e.clientY;console.log(`Mouse is at (${mouseX}, ${mouseY})`);});canvasTag.addEventListener('mousemove',(e)=>{const mouseX=(e.clientX/window.innerWidth)*2-1;const mouseY=(-e.clientY/window.innerHeight)*2+1;console.log(`Mouse is at (${mouseX}, ${mouseY})`);});canvasTag.addEventListener('mousemove',(e)=>{var mouseX=(e.clientX/window.innerWidth)*2-1;var mouseY=(-e.clientY/window.innerHeight)*2+1;mouseX/=camera._pose[4];mouseY/=camera._pose[5];let p=PGA2D.applyMotorToPoint([mouseX,mouseY],[camera._pose[0],camera._pose[1],camera._pose[2],camera._pose[3]]);console.log(`Mouse is at (${p[0]}, ${p[1]})`);});canvasTag.addEventListener('mousemove',(e)=>{if(!dragging)return;const ndc=mouseToNDC(e);const dx=ndc[0]-prevP.x;const dy=ndc[1]-prevP.y;let diff=Math.sqrt(Math.pow(dx,2)+Math.pow(dy,2));if(diff>0.001){prevP.x=ndc[0];prevP.y=ndc[1];if(dx>0)camera.moveRight(-dx);else camera.moveLeft(dx);if(dy>0)camera.moveUp(-dy);else camera.moveDown(dy);triangle.updateCameraPose();renderer.render();}});canvasTag.addEventListener('mousedown',(e)=>{dragging=true;const ndc=mouseToNDC(e);prevP.x=ndc[0];prevP.y=ndc[1];});canvasTag.addEventListener('mouseup',(e)=>{dragging=false;});canvasTag.addEventListener('mouseleave',(e)=>{dragging=false;});canvasTag.addEventListener('mousemove',(e)=>{var mouseX=(e.clientX/window.innerWidth)*2-1;var mouseY=(-e.clientY/window.innerHeight)*2+1;mouseX/=camera._pose[4];mouseY/=camera._pose[5];let p=PGA2D.applyMotorToPoint([mouseX,mouseY],[camera._pose[0],camera._pose[1],camera._pose[2],camera._pose[3]]);let halfLength=1;let cellLength=halfLength*2;let u=Math.floor((p[0]+halfLength)/cellLength*DIMENSION);let v=Math.floor((p[1]+halfLength)/cellLength*DIMENSION);console.log(`Closest offset is (${u}, ${v})`);if(u>=0&&u<DIMENSION&&v>=0&&v<DIMENSION){let offsetX=-halfLength+u/DIMENSION*cellLength+cellLength/DIMENSION*0.5;let offsetY=-halfLength+v/DIMENSION*cellLength+cellLength/DIMENSION*0.5;if(-0.5/DIMENSION+offsetX<=p[0]&&p[0]<=0.5/DIMENSION+offsetX&&-0.5/DIMENSION+offsetY<=p[1]&&p[1]<=0.5/DIMENSION+offsetY){console.log(`in cell (${u}, ${v})`);}}});do_fps_stuff(FPS);let renderFrame=()=>{let elapsed=Date.now()-lastCalled;if(elapsed>frameInterval){++frameCnt;lastCalled=Date.now()-(elapsed%frameInterval);renderer.render();}
requestAnimationFrame(renderFrame);};lastCalled=Date.now();renderFrame();setInterval(()=>{fpsText.updateText('fps: '+frameCnt);frameCnt=0;},1000);return renderer;}
init().then(ret=>{console.log(ret);}).catch(error=>{const pTag=document.createElement('p');pTag.innerHTML=navigator.userAgent+"</br>"+error.message;document.body.appendChild(pTag);document.getElementById("renderCanvas").remove();});